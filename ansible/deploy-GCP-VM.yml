# "connect" to localhost to execute commands
- hosts: localhost
  gather_facts: no
  tasks:
  - name:
# confirm that the google-auth and google-cloud-compute Python packages are installed using pip
      name: 
        - google-auth
        - google-cloud-compute
      state: present
# line 10 checks if the above packages are installed, if they aren't ansible will install, if they are, ansible will proceed as normal

# terminate GCP instances tagged/named "instance-1" by declaring a goal state of absent (terminated)
- name: terminate existing instance-1 instances
  community.general.gcp_compute_instance:
    name: "instance-1"
    zone: "{{ lookup('ansible.builtin.env','zone') }}"
    project: "{{ lookup('ansible.builtin.env','PROJECT_ID') }}"
    auth_kind: serviceaccount
    service_account_file: "{{ lookup('ansible.builtin.env','CREDENTIALS_FILE') }}"
    state: absent

# Look up the list of subnets and register the output and store it as variable "subnet_info"
- name: Get subnet info
  community.gcp.gcp_compute_subnetwork_info:
    project: "{{ lookup('ansible.builtin.env', 'PROJECT_ID') }}"
    auth_kind: serviceaccount
    service_account_file: "{{ lookup('ansible.builtin.env', 'CREDENTIALS_FILE') }}"
  register: subnet_info

# Creates a security group named "WebSG" with rules to allow SSH traffic through port 22 and HTTP traffic through port 80, 
# and egress traffic for all protocols and IPs, using GCP's "gcp_compute_firewall" module.
- name: creating firewall rule for instance-1 instance
  gcp_compute_firewall:
    name: web-fw
    direction: ingress
    priority: 1000
    source_ranges:
    - 0.0.0.0/0
    allowed:
    - IPProtocol: tcp
      ports:
      - 22
    - IPProtocol: tcp
      ports:
      - 80
    network: default
    project: "{{ lookup('ansible.builtin.env', 'PROJECT_ID') }}"
    auth_kind: serviceaccount
    service_account_file: "{{ lookup('ansible.builtin.env', 'CREDENTIALS_FILE') }}"
  register: firewall_info

# Key pair for instance ssh authentication
- name: create new instance ssh key pair using a public ssh key
  google.cloud.gcp_compute_ssh_key:
    name: webkey
    project: "{{ lookup('ansible.builtin.env','PROJECT_ID') }}"
    private_key_file: "{{ lookup('file',lookup('ansible.builtin.env', 'SSH_PRIVATE_KEY')) }}"
    public_key_file: "{{ lookup('file',lookup('ansible.builtin.env', 'SSH_PUBLIC_KEY')) }}"
    state: present

  # ec2 instance using Amazon Linux 2 AMI (https://aws.amazon.com/marketplace/pp/prodview-zc4x2k7vt6rpu)
  # https://docs.ansible.com/ansible/latest/collections/amazon/aws/ec2_instance_module.html
  - name: launching ec2 instance for ansible_demo
    amazon.aws.ec2_instance:
      key_name: webkey # use previously created key pair for authentication
      instance_type: t2.micro
      image_id: ami-0dfcb1ef8550277af
      state: running # we want the goal state to be running
      wait: true # wait for the goal state to be reached before moving on
      security_group: WebSG # use previously created security group
      count: 1 # only launch 1 instance
      vpc_subnet_id: "{{ subnet_info.subnets[0].id }}" # fetch the first subnet id from the earlier fetched list
      network:
        assign_public_ip: true
      region: "{{ lookup('ansible.builtin.env', 'region') }}"
      aws_access_key: "{{ lookup('ansible.builtin.env', 'access_key') }}"
      aws_secret_key: "{{ lookup('ansible.builtin.env', 'secret_key') }}"
      tags:
        Name: ansible_demo # the name for the ec2 instance
    register: ec2 

  - name: add all newly created instances to ansible_demo_host_group
    add_host:
      hostname: "{{ item.public_ip_address }}"
      groupname: ansible_demo_host_group
    loop: "{{ ec2.instances }}"

  - name: wait for ssh to come up
    wait_for:
      host: "{{ item.public_dns_name }}"
      port: 22
      state: started
    loop: "{{ ec2.instances }}"

# connect to ec2 instances to run the httpdserver role
- hosts: ansible_demo_host_group
  gather_facts: no
  remote_user: ec2-user # default aws ec2 linux user is ec2-user
  become_method: sudo 
  become: yes
  tasks:
  - name: running role
    include_role:
      name: httpdserver