# "connect" to localhost to execute commands
- hosts: localhost
  gather_facts: no
  tasks:
  - name:
# confirm that the google-auth and google-cloud-compute Python packages are installed using pip
      name: 
        - google-auth
        - google-cloud-compute
      state: present
# line 10 checks if the above packages are installed, if they aren't ansible will install, if they are, ansible will proceed as normal

# terminate GCP instances tagged/named "instance-1" by declaring a goal state of absent (terminated)
- name: terminate existing instance-1 instances
  community.general.gcp_compute_instance:
    name: "instance-1"
    zone: "{{ lookup('ansible.builtin.env','zone') }}"
    project: "{{ lookup('ansible.builtin.env','PROJECT_ID') }}"
    auth_kind: serviceaccount
    service_account_file: "{{ lookup('ansible.builtin.env','CREDENTIALS_FILE') }}"
    state: absent

# Look up the list of subnets and register the output and store it as variable "subnet_info"
- name: Get subnet info
  community.gcp.gcp_compute_subnetwork_info:
    project: "{{ lookup('ansible.builtin.env', 'PROJECT_ID') }}"
    auth_kind: serviceaccount
    service_account_file: "{{ lookup('ansible.builtin.env', 'CREDENTIALS_FILE') }}"
  register: subnet_info

# Creates a security group named "WebSG" with rules to allow SSH traffic through port 22 and HTTP traffic through port 80, 
# and egress traffic for all protocols and IPs, using GCP's "gcp_compute_firewall" module.
- name: creating firewall rule for instance-1 instance
  gcp_compute_firewall:
    name: web-fw
    direction: ingress
    priority: 1000
    source_ranges:
    - 0.0.0.0/0
    allowed:
    - IPProtocol: tcp
      ports:
      - 22
    - IPProtocol: tcp
      ports:
      - 80
    network: default
    project: "{{ lookup('ansible.builtin.env', 'PROJECT_ID') }}"
    auth_kind: serviceaccount
    service_account_file: "{{ lookup('ansible.builtin.env', 'CREDENTIALS_FILE') }}"
  register: firewall_info

# Key pair for instance ssh authentication
- name: create new instance ssh key pair using a public ssh key
  google.cloud.gcp_compute_ssh_key:
    name: webkey
    project: "{{ lookup('ansible.builtin.env','PROJECT_ID') }}"
    private_key_file: "{{ lookup('file',lookup('ansible.builtin.env', 'SSH_PRIVATE_KEY')) }}"
    public_key_file: "{{ lookup('file',lookup('ansible.builtin.env', 'SSH_PUBLIC_KEY')) }}"
    state: present

# Launching GCP instance for instance-1
- name: launching GCP instance for instance-1
  gcp_compute_instance:
    name: instance-1
    machine_type: f1-micro
    zone: "{{ lookup('ansible.builtin.env', 'zone') }}"
    tags:
      items:
        - instance-1
    boot_disk_auto_delete: true
    boot_disk_initialize_params:
      source_image: projects/debian-cloud/global/images/family/debian-10
    network_interfaces:
      - access_configs:
          - name: External NAT
            type: ONE_TO_ONE_NAT
        network: global/networks/default
    project_id: "{{ lookup('ansible.builtin.env', 'PROJECT_ID') }}"
    auth_kind: serviceaccount
    service_account_file: "{{ lookup('env', 'CREDENTIALS_FILE') }}"
  register: instance

  - name: add all newly created instances to ansible_demo_host_group
    add_host:
      hostname: "{{ item.networkInterfaces[0].accessConfigs[0].natIP }}"
      groupname: ansible_demo_host_group
    loop: "{{ gce.instances }}"

  - name: wait for ssh to come up
    wait_for:
      host: "{{ item.networkInterfaces[0].accessConfigs[0].natIP }}"
      port: 22
      state: started
    loop: "{{ gce.instances }}"


# connect to GCE instances to run the httpdserver role
- hosts: ansible_demo_host_group
  gather_facts: no
  remote_user: ansible # default GCE Linux user is ansible
  become_method: sudo 
  become: yes
  tasks:
  - name: running role
    include_role:
      name: httpdserver
